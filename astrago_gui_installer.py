import curses
import os
import pathlib
import re
import subprocess
import sys
from datetime import datetime, timezone, timedelta
from pathlib import Path

import yaml

ESCAPE_CODE = -1
REGEX_NODE_NAME = r'^[a-zA-Z0-9-]+$'
REGEX_IP_ADDRESS = r'^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$'
REGEX_PATH = r'^\/(?:[a-zA-Z0-9_-]+\/?)*$'
REGEX_URL = r'^https?://[^\s/$.?#].[^\s]*$|^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}(:[0-9]+)?$'

# ==========================================
# üé® Beautiful Color Definitions
# ==========================================
# Color pairs will be initialized in the main function
COLOR_GRADIENT1 = 1
COLOR_GRADIENT2 = 2  
COLOR_GRADIENT3 = 3
COLOR_GRADIENT4 = 4
COLOR_SUCCESS = 5
COLOR_ERROR = 6
COLOR_WARNING = 7
COLOR_INFO = 8
COLOR_SELECTED = 9
COLOR_BORDER = 10

# ==========================================
# üéØ Beautiful Unicode Box Characters
# ==========================================
BOX_CHARS = {
    'top_left': '‚ïî',
    'top_right': '‚ïó', 
    'bottom_left': '‚ïö',
    'bottom_right': '‚ïù',
    'horizontal': '‚ïê',
    'vertical': '‚ïë',
    'section_top_left': '‚îå',
    'section_top_right': '‚îê',
    'section_bottom_left': '‚îî', 
    'section_bottom_right': '‚îò',
    'section_horizontal': '‚îÄ',
    'section_vertical': '‚îÇ'
}

# ÌôòÍ≤Ω Î≥ÄÏàòÏóêÏÑú ÏÑ§Ïπò Î™®Îìú Í∞ÄÏ†∏Ïò§Í∏∞
INSTALLATION_MODE = os.environ.get('ASTRAGO_INSTALLATION_MODE', 'online')

class DataManager:
    def __init__(self):
        self.nodes = []
        self.nfs_server = {
            'ip': '',
            'path': ''
        }
        self.environment_config = {
            'externalIP': '',
            'nfs': {
                'server': '',
                'basePath': ''
            },
            'offline': {
                'registry': '',
                'httpServer': ''
            }
        }
        self.save_nodes_file = 'nodes.yaml'
        self.save_nfs_server_file = 'nfs-servers.yaml'
        self.environment_name = 'astrago'
        
        # Load existing data
        self._load_data()

    def _load_data(self):
        # Load nodes from inventory file if it exists
        if os.path.exists(self.save_nodes_file):
            with open(self.save_nodes_file, 'r', encoding='utf-8') as f:
                self.nodes = yaml.safe_load(f) or []

        # Load NFS server config
        if os.path.exists(self.save_nfs_server_file):
            with open(self.save_nfs_server_file, 'r', encoding='utf-8') as f:
                self.nfs_server = yaml.safe_load(f) or {'ip': '', 'path': ''}

        # Load environment config
        env_file = f'environments/{self.environment_name}/values.yaml'
        if os.path.exists(env_file):
            with open(env_file, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f) or {}
                self.environment_config.update(config)

    def _save_to_nodes(self):
        with open(self.save_nodes_file, 'w', encoding='utf-8') as f:
            yaml.dump(self.nodes, f, default_flow_style=False, allow_unicode=True)

    def _save_to_nfs(self):
        with open(self.save_nfs_server_file, 'w', encoding='utf-8') as f:
            yaml.dump(self.nfs_server, f, default_flow_style=False, allow_unicode=True)

    def _save_environment_config(self):
        env_dir = f'environments/{self.environment_name}'
        os.makedirs(env_dir, exist_ok=True)
        
        env_file = f'{env_dir}/values.yaml'
        with open(env_file, 'w', encoding='utf-8') as f:
            yaml.dump(self.environment_config, f, default_flow_style=False, allow_unicode=True)

    def set_nfs_server(self, ip, path):
        self.nfs_server['ip'] = ip
        self.nfs_server['path'] = path
        self.environment_config['nfs']['server'] = ip
        self.environment_config['nfs']['basePath'] = path
        self._save_to_nfs()
        self._save_environment_config()

    def set_external_ip(self, ip):
        self.environment_config['externalIP'] = ip
        self._save_environment_config()

    def set_offline_config(self, registry, http_server):
        self.environment_config['offline']['registry'] = registry
        self.environment_config['offline']['httpServer'] = http_server
        self._save_environment_config()

    def get_environment_status(self):
        """ÌôòÍ≤Ω ÏÑ§Ï†ï ÏÉÅÌÉúÎ•º Î∞òÌôò"""
        status = {
            'configured': False,
            'external_ip': self.environment_config.get('externalIP', ''),
            'nfs_server': self.environment_config.get('nfs', {}).get('server', ''),
            'nfs_path': self.environment_config.get('nfs', {}).get('basePath', ''),
            'offline_registry': self.environment_config.get('offline', {}).get('registry', ''),
            'offline_http': self.environment_config.get('offline', {}).get('httpServer', ''),
            'nodes_count': len(self.nodes)
        }
        
        # Í∏∞Î≥∏ ÏÑ§Ï†ïÏù¥ ÏôÑÎ£åÎêòÏóàÎäîÏßÄ ÌôïÏù∏
        status['configured'] = bool(
            status['external_ip'] and 
            status['nfs_server'] and 
            status['nfs_path'] and
            status['nodes_count'] > 0
        )
        
        return status

    def add_node(self, name, ip, role, etcd):
        self.nodes.append({
            'name': name,
            'ip': ip,
            'role': role,
            'etcd': etcd
        })
        self._save_to_nodes()

    def remove_node(self, index):
        if 0 <= index < len(self.nodes):
            del self.nodes[index]
            self._save_to_nodes()

    def edit_node(self, index, name, ip, role, etcd):
        if 0 <= index < len(self.nodes):
            self.nodes[index]['name'] = name
            self.nodes[index]['ip'] = ip
            self.nodes[index]['role'] = role
            self.nodes[index]['etcd'] = etcd
            self._save_to_nodes()

    def list_nodes(self):
        return self.nodes

    def validate_ip(self, ip):
        """IP Ï£ºÏÜå Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨"""
        return bool(re.match(REGEX_IP_ADDRESS, ip))

    def validate_url(self, url):
        """URL Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨"""
        return bool(re.match(REGEX_URL, url))

    def validate_node_name(self, name):
        """ÎÖ∏Îìú Ïù¥Î¶Ñ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (Kubernetes ÌëúÏ§Ä)"""
        if not name or len(name) > 63:
            return False
        return bool(re.match(r'^[a-z0-9]([a-z0-9-]*[a-z0-9])?$', name))

    def validate_path(self, path):
        """Í≤ΩÎ°ú Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨"""
        return bool(re.match(REGEX_PATH, path))


class CommandRunner:
    def __init__(self, data_manager):
        self.data_manager = data_manager
        self.current_dir = Path.cwd()
        self.kubespray_inventory_path = self.current_dir / 'kubespray/inventory/mycluster/astrago.yaml'
        self.nfs_inventory_path = '/tmp/nfs_inventory'
        self.gpu_inventory_path = '/tmp/gpu_inventory'
        self.ansible_extra_values = 'reset_confirmation=yes ansible_ssh_timeout=30 ansible_user={username}' \
                                    ' ansible_password={password} ansible_become_pass={password}'

    def _save_kubespray_inventory(self):
        """Kubespray Ïù∏Î≤§ÌÜ†Î¶¨ ÌååÏùº ÏÉùÏÑ±"""
        inventory = {
            'all': {
                'children': {
                    'calico-rr': {'hosts': {}},
                    'etcd': {'hosts': {}},
                    'k8s-cluster': {
                        'children': {
                            'kube-master': {'hosts': {}},
                            'kube-node': {'hosts': {}}
                        }
                    },
                    'kube-master': {'hosts': {}},
                    'kube-node': {'hosts': {}}
                },
                'hosts': {}
            }
        }

        for node in self.data_manager.nodes:
            inventory['all']['hosts'][node['name']] = {
                'ansible_host': node['ip'],
                'ip': node['ip'],
                'access_ip': node['ip']
            }

            # Add node to appropriate group based on roles
            roles = node['role'].split(',')
            for role in roles:
                role = role.strip()
                if role == 'kube-master':
                    inventory['all']['children']['kube-master']['hosts'][node['name']] = None
                elif role == 'kube-node':
                    inventory['all']['children']['kube-node']['hosts'][node['name']] = None

            # Add node to etcd group if applicable
            if node['etcd'] == 'Y':
                inventory['all']['children']['etcd']['hosts'][node['name']] = None

        # Ensure directory exists
        os.makedirs(self.kubespray_inventory_path.parent, exist_ok=True)
        
        with open(self.kubespray_inventory_path, 'w', encoding='utf-8') as f:
            yaml.dump(inventory, f, default_flow_style=False, allow_unicode=True)

    def _apply_offline_settings(self):
        """Ïò§ÌîÑÎùºÏù∏ ÏÑ§Ï†ï Ï†ÅÏö©"""
        if INSTALLATION_MODE != 'offline':
            return

        offline_config_dir = self.current_dir / 'kubespray/inventory/mycluster/group_vars/all'
        offline_config_file = offline_config_dir / 'offline.yml'
        
        # Create directory if it doesn't exist
        os.makedirs(offline_config_dir, exist_ok=True)
        
        # Get offline settings
        offline_config = self.data_manager.environment_config.get('offline', {})
        registry_host = offline_config.get('registry', '')
        http_server = offline_config.get('httpServer', '')
        
        if registry_host and http_server:
            offline_content = f"""# Offline configuration for kubespray
http_server: "{http_server}"
registry_host: "{registry_host}"

# Insecure registries for containerd
containerd_registries_mirrors:
  - prefix: "{{{{ registry_host }}}}"
    mirrors:
      - host: "http://{{{{ registry_host }}}}"
        capabilities: ["pull", "resolve"]
        skip_verify: true

files_repo: "{{{{ http_server }}}}/files"
yum_repo: "{{{{ http_server }}}}/rpms"
ubuntu_repo: "{{{{ http_server }}}}/debs"

# Registry overrides
kube_image_repo: "{{{{ registry_host }}}}"
gcr_image_repo: "{{{{ registry_host }}}}"
docker_image_repo: "{{{{ registry_host }}}}"
quay_image_repo: "{{{{ registry_host }}}}"
"""
            
            with open(offline_config_file, 'w', encoding='utf-8') as f:
                f.write(offline_content)

    def _run_command(self, cmd, cwd=None):
        """Î™ÖÎ†πÏñ¥ Ïã§Ìñâ"""
        if cwd is None:
            cwd = self.current_dir
        return subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, 
                              text=True, cwd=cwd, encoding='utf-8')

    def run_prepare_offline_packages(self):
        """Ïò§ÌîÑÎùºÏù∏ Ìå®ÌÇ§ÏßÄ Ï§ÄÎπÑ"""
        if INSTALLATION_MODE != 'offline':
            return None
            
        airgap_dir = self.current_dir / 'airgap/kubespray-offline'
        if not airgap_dir.exists():
            return None
            
        download_script = airgap_dir / 'download-all.sh'
        if not download_script.exists():
            return None
            
        return self._run_command(['bash', str(download_script)], cwd=airgap_dir)

    def run_kubespray_install(self, username, password):
        """Kubernetes ÌÅ¥Îü¨Ïä§ÌÑ∞ ÏÑ§Ïπò"""
        self._save_kubespray_inventory()
        self._apply_offline_settings()
        
        if INSTALLATION_MODE == 'offline':
            # Ïò§ÌîÑÎùºÏù∏ Î™®ÎìúÏóêÏÑúÎäî Í∏∞Ï°¥ airgap Ïä§ÌÅ¨Î¶ΩÌä∏ ÏÇ¨Ïö©
            airgap_script = self.current_dir / 'airgap/deploy_kubernetes.sh'
            if airgap_script.exists():
                return self._run_command(['bash', str(airgap_script)], cwd=self.current_dir / 'airgap')
        
        # Ïò®ÎùºÏù∏ Î™®Îìú ÎòêÎäî Ïò§ÌîÑÎùºÏù∏ Ïä§ÌÅ¨Î¶ΩÌä∏Í∞Ä ÏóÜÎäî Í≤ΩÏö∞
        kubespray_dir = self.current_dir / 'kubespray'
        cmd = [
            "ansible-playbook",
            "-i", str(self.kubespray_inventory_path),
            "--become", "--become-user=root",
            "cluster.yml",
            "--extra-vars",
            self.ansible_extra_values.format(username=username, password=password)
        ]
        
        if INSTALLATION_MODE == 'offline':
            # Ïò§ÌîÑÎùºÏù∏ Ï†ÄÏû•ÏÜå ÏÑ§Ï†ï Î®ºÏ†Ä Ïã§Ìñâ
            offline_repo_cmd = [
                "ansible-playbook",
                "-i", str(self.kubespray_inventory_path),
                "--become", "--become-user=root",
                str(self.current_dir / "ansible/offline-repo.yml"),
                "--extra-vars",
                self.ansible_extra_values.format(username=username, password=password)
            ]
            # Ïó¨Í∏∞ÏÑúÎäî Ï≤´ Î≤àÏß∏ Î™ÖÎ†πÏñ¥Îßå Î∞òÌôò (UIÏóêÏÑú ÏàúÏ∞®Ï†ÅÏúºÎ°ú Ïã§ÌñâÌï¥Ïïº Ìï®)
            return self._run_command(offline_repo_cmd, cwd=kubespray_dir)
        
        return self._run_command(cmd, cwd=kubespray_dir)

    def run_kubespray_reset(self, username, password):
        """Kubernetes ÌÅ¥Îü¨Ïä§ÌÑ∞ Î¶¨ÏÖã"""
        self._save_kubespray_inventory()
        return self._run_command([
            "ansible-playbook",
            "-i", str(self.kubespray_inventory_path),
            "--become", "--become-user=root",
            "reset.yml",
            "--extra-vars",
            self.ansible_extra_values.format(username=username, password=password)
        ], cwd=self.current_dir / 'kubespray')

    def run_install_astrago(self, app_name=None):
        """Astrago Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏÑ§Ïπò"""
        cmd = ["helmfile", "-e", self.data_manager.environment_name]
        if app_name:
            cmd.extend(["-l", f"app={app_name}"])
        cmd.append("sync")
        
        return self._run_command(cmd)

    def run_uninstall_astrago(self, app_name=None):
        """Astrago Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ï†úÍ±∞"""
        cmd = ["helmfile", "-e", self.data_manager.environment_name]
        if app_name:
            cmd.extend(["-l", f"app={app_name}"])
        cmd.append("destroy")
        
        return self._run_command(cmd)

    def run_status_check(self):
        """ÏãúÏä§ÌÖú ÏÉÅÌÉú ÌôïÏù∏"""
        cmd = ["helmfile", "-e", self.data_manager.environment_name, "list"]
        return self._run_command(cmd)

    def _save_nfs_inventory(self):
        """NFS Ïù∏Î≤§ÌÜ†Î¶¨ ÌååÏùº ÏÉùÏÑ±"""
        inventory = {
            'all': {
                'vars': {
                    'nfs_exports': [
                        f"{self.data_manager.nfs_server['path']} *(rw,sync,no_subtree_check,no_root_squash)"
                    ]
                },
                'hosts': {
                    'nfs-server': {
                        'access_ip': self.data_manager.nfs_server['ip'],
                        'ansible_host': self.data_manager.nfs_server['ip'],
                        'ip': self.data_manager.nfs_server['ip'],
                        'ansible_user': 'root'
                    }
                }
            }
        }
        
        with open(self.nfs_inventory_path, 'w', encoding='utf-8') as f:
            yaml.dump(inventory, f, default_flow_style=False, allow_unicode=True)

    def run_install_nfs(self, username, password):
        """NFS ÏÑúÎ≤Ñ ÏÑ§Ïπò"""
        self._save_nfs_inventory()
        return self._run_command([
            "ansible-playbook", "-i", self.nfs_inventory_path,
            "--become", "--become-user=root",
            "ansible/install-nfs.yml",
            "--extra-vars",
            self.ansible_extra_values.format(username=username, password=password)
        ])

    def _save_gpudriver_inventory(self):
        """GPU ÎìúÎùºÏù¥Î≤Ñ Ïù∏Î≤§ÌÜ†Î¶¨ ÌååÏùº ÏÉùÏÑ±"""
        inventory = {
            'all': {
                'vars': {
                    "nvidia_driver_branch": "535",
                    "nvidia_driver_package_state": "present"
                },
                'hosts': {}
            }
        }
        
        for node in self.data_manager.list_nodes():
            inventory['all']['hosts'][node['name']] = {
                'ansible_host': node['ip'],
                'ip': node['ip'],
                'access_ip': node['ip']
            }

        with open(self.gpu_inventory_path, 'w', encoding='utf-8') as f:
            yaml.dump(inventory, f, default_flow_style=False, allow_unicode=True)

    def run_install_gpudriver(self, username, password):
        """GPU ÎìúÎùºÏù¥Î≤Ñ ÏÑ§Ïπò"""
        self._save_gpudriver_inventory()
        return self._run_command([
            "ansible-playbook", "-i", self.gpu_inventory_path,
            "--become", "--become-user=root",
            "ansible/install-gpu-driver.yml",
            "--extra-vars",
            self.ansible_extra_values.format(username=username, password=password)
        ])


class AstragoInstaller:
    def __init__(self):
        self.data_manager = DataManager()
        self.command_runner = CommandRunner(self.data_manager)
        self.stdscr = None
        self.installation_mode = INSTALLATION_MODE

    def read_and_display_output(self, process):
        """Î™ÖÎ†πÏñ¥ Ï∂úÎ†•ÏùÑ Ïã§ÏãúÍ∞ÑÏúºÎ°ú ÌëúÏãú"""
        if process is None:
            self.stdscr.clear()
            self.stdscr.addstr(0, 0, "Î™ÖÎ†πÏñ¥Î•º Ïã§ÌñâÌï† Ïàò ÏóÜÏäµÎãàÎã§.")
            self.stdscr.addstr(1, 0, "ÏïÑÎ¨¥ ÌÇ§ÎÇò ÎàåÎü¨ Î©îÎâ¥Î°ú ÎèåÏïÑÍ∞ÄÏÑ∏Ïöî")
            self.stdscr.refresh()
            curses.flushinp()
            self.stdscr.getch()
            return

        self.stdscr.clear()
        h, w = self.stdscr.getmaxyx()
        output_lines = []
        
        # ÏÉÅÎã® Ï†úÎ™© Î∞ïÏä§
        title_width = min(w - 4, 70)
        title_x = (w - title_width) // 2
        self.print_beautiful_box(0, title_x, title_width, 3, "üîÑ Installation Progress", COLOR_GRADIENT1)
        
        # Ï∂úÎ†• ÏòÅÏó≠
        output_start_y = 4
        max_lines = h - output_start_y - 3

        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                output_lines.append(output.strip())
                if len(output_lines) > max_lines:
                    output_lines = output_lines[-max_lines:]
                
                # Ï∂úÎ†• ÏòÅÏó≠ ÏßÄÏö∞Í∏∞
                for i in range(output_start_y, h - 2):
                    if i < h and w > 1:
                        try:
                            self.stdscr.addstr(i, 0, " " * (w - 1))
                        except curses.error:
                            pass
                
                # Ï∂úÎ†• ÌëúÏãú
                for idx, line in enumerate(output_lines):
                    if output_start_y + idx < h - 2:
                        display_line = line[:w - 1]
                        # Î°úÍ∑∏ Î†àÎ≤®Ïóê Îî∞Î•∏ ÏÉâÏÉÅ
                        if "ERROR" in line or "Failed" in line:
                            color = COLOR_ERROR
                        elif "WARNING" in line or "WARN" in line:
                            color = COLOR_WARNING
                        elif "SUCCESS" in line or "Completed" in line:
                            color = COLOR_SUCCESS
                        else:
                            color = COLOR_INFO
                        
                        try:
                            self.stdscr.addstr(output_start_y + idx, 0, display_line, curses.color_pair(color))
                        except curses.error:
                            pass
                
                self.stdscr.refresh()
        
        process.stdout.close()
        process.wait()
        
        # ÏôÑÎ£å Î©îÏãúÏßÄ
        completion_y = h - 2
        if completion_y > 0:
            completion_msg = "üéâ Installation completed! Press any key to return to the menu"
            msg_x = max(0, (w - len(completion_msg)) // 2)
            try:
                self.stdscr.addstr(completion_y, msg_x, completion_msg, curses.color_pair(COLOR_SUCCESS) | curses.A_BOLD)
            except curses.error:
                pass
        
        self.stdscr.refresh()
        curses.flushinp()
        self.stdscr.getch()

    def print_beautiful_box(self, y, x, width, height, title="", color_pair=COLOR_GRADIENT1):
        """ÏïÑÎ¶ÑÎã§Ïö¥ Î∞ïÏä§Î•º Í∑∏Î¶ΩÎãàÎã§"""
        h, w = self.stdscr.getmaxyx()
        
        # Î∞ïÏä§ Í∑∏Î¶¨Í∏∞
        if y < h and x < w:
            # ÏÉÅÎã®
            self.stdscr.addstr(y, x, BOX_CHARS['top_left'], curses.color_pair(color_pair))
            for i in range(1, width-1):
                if x + i < w:
                    self.stdscr.addstr(y, x + i, BOX_CHARS['horizontal'], curses.color_pair(color_pair))
            if x + width - 1 < w:
                self.stdscr.addstr(y, x + width - 1, BOX_CHARS['top_right'], curses.color_pair(color_pair))
            
            # Ï§ëÍ∞Ñ ÎùºÏù∏Îì§
            for j in range(1, height-1):
                if y + j < h:
                    if x < w:
                        self.stdscr.addstr(y + j, x, BOX_CHARS['vertical'], curses.color_pair(color_pair))
                    if x + width - 1 < w:
                        self.stdscr.addstr(y + j, x + width - 1, BOX_CHARS['vertical'], curses.color_pair(color_pair))
            
            # ÌïòÎã®
            if y + height - 1 < h:
                if x < w:
                    self.stdscr.addstr(y + height - 1, x, BOX_CHARS['bottom_left'], curses.color_pair(color_pair))
                for i in range(1, width-1):
                    if x + i < w:
                        self.stdscr.addstr(y + height - 1, x + i, BOX_CHARS['horizontal'], curses.color_pair(color_pair))
                if x + width - 1 < w:
                    self.stdscr.addstr(y + height - 1, x + width - 1, BOX_CHARS['bottom_right'], curses.color_pair(color_pair))
        
        # Ï†úÎ™© Ï∂îÍ∞Ä
        if title and len(title) < width - 4:
            title_x = x + (width - len(title)) // 2
            if title_x < w and y < h:
                self.stdscr.addstr(y, title_x, f" {title} ", curses.color_pair(color_pair) | curses.A_BOLD)

    def print_banner(self):
        """Î∞∞ÎÑà Ï∂úÎ†•"""
        self.stdscr.clear()
        title = [
            "    ___         __                         ",
            "   /   |  _____/ /__________ _____ _____   ",
            "  / /| | / ___/ __/ ___/ __ `/ __ `/ __ \\ ",
            " / ___ |(__  ) /_/ /  / /_/ / /_/ / /_/ /  ",
            "/_/  |_/____/\\__/_/   \\__,_/\\__, /\\____/   ",
            "                           /____/          ",
        ]
        now_utc = datetime.now(timezone.utc)
        now_kst = now_utc + timedelta(hours=9)
        current_hour = now_kst.hour
        if current_hour >= 21:
            title = [
                " ‚ñÑ‚ñÑ‚ñÑ        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñì ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà   ‚ñÑ‚ñÑ‚ñÑ        ‚ñÑ‚ñà‚ñà‚ñà‚ñà  ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà  ",
                "‚ñí‚ñà‚ñà‚ñà‚ñà‚ñÑ    ‚ñí‚ñà‚ñà    ‚ñí ‚ñì  ‚ñà‚ñà‚ñí ‚ñì‚ñí‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñà‚ñà‚ñÑ     ‚ñà‚ñà‚ñí ‚ñÄ‚ñà‚ñí‚ñí‚ñà‚ñà‚ñí  ‚ñà‚ñà‚ñí",
                "‚ñí‚ñà‚ñà  ‚ñÄ‚ñà‚ñÑ  ‚ñë ‚ñì‚ñà‚ñà‚ñÑ   ‚ñí ‚ñì‚ñà‚ñà‚ñë ‚ñí‚ñë‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí‚ñí‚ñà‚ñà  ‚ñÄ‚ñà‚ñÑ  ‚ñí‚ñà‚ñà‚ñë‚ñÑ‚ñÑ‚ñÑ‚ñë‚ñí‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí",
                "‚ñë‚ñà‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñà   ‚ñí   ‚ñà‚ñà‚ñí‚ñë ‚ñì‚ñà‚ñà‚ñì ‚ñë ‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ  ‚ñë‚ñà‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñà ‚ñë‚ñì‚ñà  ‚ñà‚ñà‚ñì‚ñí‚ñà‚ñà   ‚ñà‚ñà‚ñë",
                " ‚ñì‚ñà   ‚ñì‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí  ‚ñí‚ñà‚ñà‚ñí ‚ñë ‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí ‚ñì‚ñà   ‚ñì‚ñà‚ñà‚ñí‚ñë‚ñí‚ñì‚ñà‚ñà‚ñà‚ñÄ‚ñí‚ñë ‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë",
                " ‚ñí‚ñí   ‚ñì‚ñí‚ñà‚ñë‚ñí ‚ñí‚ñì‚ñí ‚ñí ‚ñë  ‚ñí ‚ñë‚ñë   ‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë ‚ñí‚ñí   ‚ñì‚ñí‚ñà‚ñë ‚ñë‚ñí   ‚ñí ‚ñë ‚ñí‚ñë‚ñí‚ñë‚ñí‚ñë ",
                "  ‚ñí   ‚ñí‚ñí ‚ñë‚ñë ‚ñë‚ñí  ‚ñë ‚ñë    ‚ñë      ‚ñë‚ñí ‚ñë ‚ñí‚ñë  ‚ñí   ‚ñí‚ñí ‚ñë  ‚ñë   ‚ñë   ‚ñë ‚ñí ‚ñí‚ñë ",
                "  ‚ñë   ‚ñí   ‚ñë  ‚ñë  ‚ñë    ‚ñë        ‚ñë‚ñë   ‚ñë   ‚ñë   ‚ñí   ‚ñë ‚ñë   ‚ñë ‚ñë ‚ñë ‚ñë ‚ñí  ",
                "  ‚ñë  ‚ñë      ‚ñë              ‚ñë           ‚ñë  ‚ñë      ‚ñë     ‚ñë ‚ñë      ",
            ]

        h, w = self.stdscr.getmaxyx()
        for idx, line in enumerate(title):
            line = line[:w - 1]
            x = w // 2 - len(line) // 2
            y = h // 2 - len(title) // 2 + idx - 10
            if 0 <= y < h and 0 <= x < w:
                self.stdscr.addstr(y, x, line[:w], curses.color_pair(2))
        self.stdscr.refresh()

    def print_menu(self, menu, selected_row_idx):
        """Î©îÎâ¥ Ï∂úÎ†•"""
        self.stdscr.clear()
        self.print_banner()
        
        h, w = self.stdscr.getmaxyx()
        x = w // 2 - len(max(menu, key=len)) // 2
        for idx, row in enumerate(menu):
            y = h // 2 - len(menu) // 2 + idx
            if 0 <= y < h and 0 <= x < w:
                if idx == selected_row_idx:
                    self.stdscr.attron(curses.color_pair(1))
                    self.stdscr.addstr(y, x, row[:w])
                    self.stdscr.attroff(curses.color_pair(1))
                else:
                    self.stdscr.addstr(y, x, row[:w])
        self.stdscr.refresh()

    def print_table(self, y, x, header, data, selected_index=-1):
        h, w = self.stdscr.getmaxyx()
        
        # Ìó§ÎçîÏôÄ Îç∞Ïù¥ÌÑ∞ ÎÑàÎπÑ Í≥ÑÏÇ∞
        header_widths = [len(str(col)) for col in header]
        data_widths = []
        
        for row in data:
            row_widths = [len(str(value)) for value in row]
            data_widths.append(row_widths)

        if data_widths:
            max_widths = [max(header_widths[i], *[row[i] for row in data_widths]) for i in range(len(header))]
        else:
            max_widths = header_widths[:]

        total_width = sum(max_widths) + len(header) - 1
        if total_width > w:
            for i in range(len(max_widths)):
                max_widths[i] = max(1, max_widths[i] * (w - len(header) + 1) // total_width)

        line = '+'.join(['-' * width for width in max_widths])

        self.stdscr.addstr(y, x, '+' + line + '+')
        y += 1
        self.stdscr.addstr(y, x, '|' + '|'.join(header[i].center(max_widths[i]) for i in range(len(header))) + '|')
        y += 1
        self.stdscr.addstr(y, x, '+' + line + '+')

        for idx, row in enumerate(data):
            new_row = [str(col).center(max_widths[i]) for i, col in enumerate(row)]
            y += 1
            if y < h - 2:
                if selected_index == idx:
                    self.stdscr.addstr(y, x, '|' + '|'.join(new_row) + '|', curses.color_pair(1))
                else:
                    self.stdscr.addstr(y, x, '|' + '|'.join(new_row) + '|')

        y += 1
        if y < h:
            self.stdscr.addstr(y, x, '+' + line + '+')
        self.stdscr.refresh()
        curses.flushinp()
        self.stdscr.getch()

    def print_nfs_server_table(self, y, x):
        """NFS ÏÑúÎ≤Ñ ÌÖåÏù¥Î∏î Ï∂úÎ†•"""
        header = ["NFS IP Ï£ºÏÜå", "NFS Í∏∞Î≥∏ Í≤ΩÎ°ú"]
        data = [(
            self.data_manager.nfs_server['ip'] or 'ÎØ∏ÏÑ§Ï†ï',
            self.data_manager.nfs_server['path'] or 'ÎØ∏ÏÑ§Ï†ï'
        )]
        self.print_table(y, x, header, data)

    def print_nodes_table(self, y, x, selected_index=-1):
        """ÎÖ∏Îìú ÌÖåÏù¥Î∏î Ï∂úÎ†•"""
        header = ["Î≤àÌò∏", "ÎÖ∏Îìú Ïù¥Î¶Ñ", "IP Ï£ºÏÜå", "Ïó≠Ìï†", "Etcd"]
        data = []
        for idx, row in enumerate(self.data_manager.nodes):
            data.append((
                str(idx + 1),
                row['name'],
                row['ip'],
                row['role'],
                row['etcd']
            ))
        self.print_table(y, x, header, data, selected_index)

    def configure_environment(self):
        """ÌôòÍ≤Ω ÏÑ§Ï†ï"""
        self.stdscr.clear()
        
        try:
            self.stdscr.addstr(0, 0, "üîß ÌôòÍ≤Ω ÏÑ§Ï†ï", curses.color_pair(1))
            self.stdscr.addstr(1, 0, "=" * 50)
            
            y = 3
            self.stdscr.addstr(y, 0, "Í∏∞Î≥∏ ÏÑ§Ï†ïÏùÑ Íµ¨ÏÑ±Ìï©ÎãàÎã§...")
            y += 2
            
            # Ïô∏Î∂Ä IP ÏÑ§Ï†ï
            external_ip = self.make_query(y, 0, "Ïô∏Î∂Ä IP Ï£ºÏÜå: ", 
                                        default_value=self.data_manager.environment_config.get('externalIP', ''),
                                        validation_func=self.data_manager.validate_ip)
            if external_ip == ESCAPE_CODE:
                return
            
            y += 1
            # NFS ÏÑúÎ≤Ñ ÏÑ§Ï†ï
            nfs_ip = self.make_query(y, 0, "NFS ÏÑúÎ≤Ñ IP: ", 
                                   default_value=self.data_manager.nfs_server.get('ip', ''),
                                   validation_func=self.data_manager.validate_ip)
            if nfs_ip == ESCAPE_CODE:
                return
            
            y += 1
            nfs_path = self.make_query(y, 0, "NFS Í∏∞Î≥∏ Í≤ΩÎ°ú: ", 
                                     default_value=self.data_manager.nfs_server.get('path', ''),
                                     validation_func=self.data_manager.validate_path)
            if nfs_path == ESCAPE_CODE:
                return
            
            # Ïò§ÌîÑÎùºÏù∏ Î™®ÎìúÏù∏ Í≤ΩÏö∞ Ï∂îÍ∞Ä ÏÑ§Ï†ï
            if self.installation_mode == 'offline':
                y += 2
                self.stdscr.addstr(y, 0, "Ïò§ÌîÑÎùºÏù∏ ÏÑ§Ï†ï:")
                y += 1
                
                offline_registry = self.make_query(y, 0, "Ïò§ÌîÑÎùºÏù∏ Î†àÏßÄÏä§Ìä∏Î¶¨ (Ïòà: 10.61.3.8:35000): ",
                                                 default_value=self.data_manager.environment_config.get('offline', {}).get('registry', ''))
                if offline_registry == ESCAPE_CODE:
                    return
                
                y += 1
                offline_http = self.make_query(y, 0, "HTTP ÏÑúÎ≤Ñ (Ïòà: http://10.61.3.8): ",
                                             default_value=self.data_manager.environment_config.get('offline', {}).get('httpServer', ''),
                                             validation_func=self.data_manager.validate_url)
                if offline_http == ESCAPE_CODE:
                    return
                
                # Ïò§ÌîÑÎùºÏù∏ ÏÑ§Ï†ï Ï†ÄÏû•
                self.data_manager.set_offline_config(offline_registry, offline_http)
            
            # ÏÑ§Ï†ï Ï†ÄÏû•
            self.data_manager.set_external_ip(external_ip)
            self.data_manager.set_nfs_server(nfs_ip, nfs_path)
            
            y += 2
            self.stdscr.addstr(y, 0, "‚úÖ ÌôòÍ≤Ω ÏÑ§Ï†ïÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!", curses.color_pair(1))
            y += 1
            self.stdscr.addstr(y, 0, "ÏïÑÎ¨¥ ÌÇ§ÎÇò ÎàåÎü¨ Í≥ÑÏÜçÌïòÏÑ∏Ïöî", curses.color_pair(2))
            
        except curses.error:
            pass
            
        self.stdscr.refresh()
        curses.flushinp()
        self.stdscr.getch()

    def prepare_offline_packages(self):
        """Ïò§ÌîÑÎùºÏù∏ Ìå®ÌÇ§ÏßÄ Ï§ÄÎπÑ"""
        if self.installation_mode != 'offline':
            self.stdscr.clear()
            self.stdscr.addstr(0, 0, "‚ùå Ïò§ÌîÑÎùºÏù∏ Î™®ÎìúÏóêÏÑúÎßå ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Í∏∞Îä•ÏûÖÎãàÎã§.", curses.color_pair(3))
            self.stdscr.addstr(2, 0, "ÏïÑÎ¨¥ ÌÇ§ÎÇò ÎàåÎü¨ Î©îÎâ¥Î°ú ÎèåÏïÑÍ∞ÄÏÑ∏Ïöî")
            self.stdscr.refresh()
            curses.flushinp()
            self.stdscr.getch()
            return

        self.stdscr.clear()
        self.stdscr.addstr(0, 0, "üì¶ Ïò§ÌîÑÎùºÏù∏ Ìå®ÌÇ§ÏßÄ Ï§ÄÎπÑ")
        self.stdscr.addstr(1, 0, "Ïò§ÌîÑÎùºÏù∏ ÏÑ§ÏπòÏóê ÌïÑÏöîÌïú Ìå®ÌÇ§ÏßÄÎì§ÏùÑ Îã§Ïö¥Î°úÎìúÌï©ÎãàÎã§...")
        self.stdscr.addstr(3, 0, "Í≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå? [y/N]: ")
        self.stdscr.refresh()
        
        key = self.stdscr.getch()
        if key not in [ord('y'), ord('Y')]:
            return
        
        process = self.command_runner.run_prepare_offline_packages()
        if process:
            self.read_and_display_output(process)
        else:
            self.stdscr.clear()
            self.stdscr.addstr(0, 0, "‚ùå Ïò§ÌîÑÎùºÏù∏ Ìå®ÌÇ§ÏßÄ Ï§ÄÎπÑ Ïä§ÌÅ¨Î¶ΩÌä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.", curses.color_pair(3))
            self.stdscr.addstr(2, 0, "ÏïÑÎ¨¥ ÌÇ§ÎÇò ÎàåÎü¨ Î©îÎâ¥Î°ú ÎèåÏïÑÍ∞ÄÏÑ∏Ïöî")
            self.stdscr.refresh()
            curses.flushinp()
            self.stdscr.getch()

    def remove_node(self):
        """ÎÖ∏Îìú Ï†úÍ±∞"""
        if not self.data_manager.nodes:
            self.stdscr.clear()
            self.stdscr.addstr(0, 0, "Ï†úÍ±∞Ìï† ÎÖ∏ÎìúÍ∞Ä ÏóÜÏäµÎãàÎã§.")
            self.stdscr.addstr(2, 0, "ÏïÑÎ¨¥ ÌÇ§ÎÇò ÎàåÎü¨ Î©îÎâ¥Î°ú ÎèåÏïÑÍ∞ÄÏÑ∏Ïöî")
            self.stdscr.refresh()
            curses.flushinp()
            self.stdscr.getch()
            return

        selected_index = 0
        while True:
            self.stdscr.clear()
            self.stdscr.addstr(0, 0, "üóëÔ∏è ÎÖ∏Îìú Ï†úÍ±∞", curses.color_pair(3))
            self.stdscr.addstr(1, 0, "Enter: ÏÑ†ÌÉùÌïú ÎÖ∏Îìú Ï†úÍ±∞ | ‚Üë‚Üì: Ïù¥Îèô | ESC: Îí§Î°úÍ∞ÄÍ∏∞")
            self.print_nodes_table(3, 0, selected_index)
            
            key = self.stdscr.getch()

            if key == curses.KEY_DOWN and selected_index < len(self.data_manager.nodes) - 1:
                selected_index += 1
            elif key == curses.KEY_UP and selected_index > 0:
                selected_index -= 1
            elif key == curses.KEY_ENTER or key in [10, 13]:
                # ÌôïÏù∏ Î©îÏãúÏßÄ
                node_name = self.data_manager.nodes[selected_index]['name']
                self.stdscr.addstr(2, 0, f"Ï†ïÎßêÎ°ú '{node_name}' ÎÖ∏ÎìúÎ•º Ï†úÍ±∞ÌïòÏãúÍ≤†ÏäµÎãàÍπå? [y/N]: ", curses.color_pair(3))
                self.stdscr.refresh()
                confirm = self.stdscr.getch()
                if confirm in [ord('y'), ord('Y')]:
                    self.data_manager.remove_node(selected_index)
                    if selected_index >= len(self.data_manager.nodes) and selected_index > 0:
                        selected_index -= 1
                    if not self.data_manager.nodes:
                        break
            elif key == curses.KEY_BACKSPACE or key == 27:
                break

    def input_node(self, node=None):
        """ÎÖ∏Îìú ÏûÖÎ†•/Ìé∏Ïßë"""
        if node is None:
            node = {
                'name': '',
                'ip': '',
                'role': 'kube-master,kube-node',
                'etcd': 'Y'
            }
        
        self.stdscr.clear()
        self.stdscr.addstr(0, 0, "‚ûï ÎÖ∏Îìú Ï†ïÎ≥¥ ÏûÖÎ†•" if not node.get('name') else "‚úèÔ∏è ÎÖ∏Îìú Ï†ïÎ≥¥ ÏàòÏ†ï", curses.color_pair(1))
        
        # ÎÖ∏Îìú Ïù¥Î¶Ñ ÏûÖÎ†•
        name = self.make_query(2, 0, f"ÎÖ∏Îìú Ïù¥Î¶Ñ [{node['name']}]: ", 
                             default_value=node['name'], 
                             validation_func=self.data_manager.validate_node_name)
        if name == ESCAPE_CODE:
            return ESCAPE_CODE

        # IP Ï£ºÏÜå ÏûÖÎ†•
        ip = self.make_query(3, 0, f"IP Ï£ºÏÜå [{node['ip']}]: ", 
                           default_value=node['ip'],
                           validation_func=self.data_manager.validate_ip)
        if ip == ESCAPE_CODE:
            return ESCAPE_CODE

        # Ïó≠Ìï† ÏÑ†ÌÉù
        role = self.select_checkbox(4, 0, "Ïó≠Ìï†: ", ["kube-master", "kube-node"], node['role'].split(','))
        if role == ESCAPE_CODE:
            return ESCAPE_CODE

        # etcd Ï∞∏Ïó¨ Ïó¨Î∂Ä
        etcd = self.select_YN(5, 0, "Etcd ÌÅ¥Îü¨Ïä§ÌÑ∞ Ï∞∏Ïó¨", node['etcd'])
        if etcd == ESCAPE_CODE:
            return ESCAPE_CODE

        return {
            'name': name,
            'ip': ip,
            'role': role,
            'etcd': etcd
        }

    def add_node(self):
        """ÎÖ∏Îìú Ï∂îÍ∞Ä"""
        node = self.input_node()
        if node == ESCAPE_CODE:
            return
        
        # Ï§ëÎ≥µ Í≤ÄÏÇ¨
        for existing_node in self.data_manager.nodes:
            if existing_node['name'] == node['name']:
                self.show_message("‚ùå Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî ÎÖ∏Îìú Ïù¥Î¶ÑÏûÖÎãàÎã§.", curses.color_pair(3))
                return
            if existing_node['ip'] == node['ip']:
                self.show_message("‚ùå Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî IP Ï£ºÏÜåÏûÖÎãàÎã§.", curses.color_pair(3))
                return
        
        self.data_manager.add_node(node['name'], node['ip'], node['role'], node['etcd'])
        self.show_message("‚úÖ ÎÖ∏ÎìúÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§!", curses.color_pair(1))

    def edit_node(self):
        """ÎÖ∏Îìú Ìé∏Ïßë"""
        if not self.data_manager.nodes:
            self.show_message("Ìé∏ÏßëÌï† ÎÖ∏ÎìúÍ∞Ä ÏóÜÏäµÎãàÎã§.")
            return

        selected_index = 0
        while True:
            self.stdscr.clear()
            self.stdscr.addstr(0, 0, "‚úèÔ∏è ÎÖ∏Îìú Ìé∏Ïßë", curses.color_pair(1))
            self.stdscr.addstr(1, 0, "Enter: ÏÑ†ÌÉùÌïú ÎÖ∏Îìú Ìé∏Ïßë | ‚Üë‚Üì: Ïù¥Îèô | ESC: Îí§Î°úÍ∞ÄÍ∏∞")
            self.print_nodes_table(3, 0, selected_index)

            key = self.stdscr.getch()

            if key == curses.KEY_DOWN and selected_index < len(self.data_manager.nodes) - 1:
                selected_index += 1
            elif key == curses.KEY_UP and selected_index > 0:
                selected_index -= 1
            elif key == curses.KEY_ENTER or key in [10, 13]:
                selected_node = self.data_manager.nodes[selected_index]
                node = self.input_node(selected_node)
                if node != ESCAPE_CODE:
                    self.data_manager.edit_node(selected_index, node['name'], node['ip'], node['role'], node['etcd'])
                    self.show_message("‚úÖ ÎÖ∏Îìú Ï†ïÎ≥¥Í∞Ä ÏóÖÎç∞Ïù¥Ìä∏ÎêòÏóàÏäµÎãàÎã§!", curses.color_pair(1))
            elif key == curses.KEY_BACKSPACE or key == 27:
                break

    def show_message(self, message, color=0):
        """Î©îÏãúÏßÄ ÌëúÏãú"""
        self.stdscr.clear()
        h, w = self.stdscr.getmaxyx()
        x = max(0, w // 2 - len(message) // 2)
        y = h // 2
        
        try:
            self.stdscr.addstr(y, x, message, color)
            self.stdscr.addstr(y + 2, x - 10, "ÏïÑÎ¨¥ ÌÇ§ÎÇò ÎàåÎü¨ Í≥ÑÏÜçÌïòÏÑ∏Ïöî", curses.color_pair(2))
        except curses.error:
            pass
            
        self.stdscr.refresh()
        curses.flushinp()
        self.stdscr.getch()

    def select_YN(self, y, x, query, selected_option='Y'):
        """Y/N ÏÑ†ÌÉù"""
        options = ['Y', 'N']
        try:
            option_idx = options.index(selected_option)
        except ValueError:
            option_idx = 0
            
        while True:
            try:
                self.stdscr.addstr(y, x, f"{query}: ")
                self.stdscr.addstr(y, x + len(query) + 2, f"‚óÄ {options[option_idx]} ‚ñ∂", curses.color_pair(2))
            except curses.error:
                pass
                
            key = self.stdscr.getch()

            if key == curses.KEY_RIGHT:
                option_idx = (option_idx + 1) % len(options)
            elif key == curses.KEY_LEFT:
                option_idx = (option_idx - 1) % len(options)
            elif key in [10, 13]:  # Enter key
                return options[option_idx]
            elif key == curses.KEY_BACKSPACE or key == 27:
                return ESCAPE_CODE
        
        return options[option_idx]

    def select_checkbox(self, y, x, query, options, default_check=[]):
        """Ï≤¥ÌÅ¨Î∞ïÏä§ ÏÑ†ÌÉù"""
        selected_roles = [option in default_check for option in options]
        role_idx = 0
        
        while True:
            try:
                self.stdscr.addstr(y, x, query)
                for idx, option in enumerate(options):
                    checkbox = "[V]" if selected_roles[idx] else "[ ]"
                    color = curses.color_pair(2) if idx == role_idx else 0
                    self.stdscr.addstr(y, x + len(query) + idx * 20, f"{checkbox} {option}", color)
            except curses.error:
                pass

            key = self.stdscr.getch()
            
            if key == curses.KEY_RIGHT:
                role_idx = (role_idx + 1) % len(options)
            elif key == curses.KEY_LEFT:
                role_idx = (role_idx - 1) % len(options)
            elif key == ord(' '):
                selected_roles[role_idx] = not selected_roles[role_idx]
            elif key in [10, 13]:  # Enter key
                if any(selected_roles):
                    break
            elif key == curses.KEY_BACKSPACE or key == 27:
                return ESCAPE_CODE
                
        return ",".join([options[i] for i in range(len(options)) if selected_roles[i]])

    def print_sub_menu(self, menu, selected_row_idx):
        h, w = self.stdscr.getmaxyx()
        for idx, row in enumerate(menu):
            if len(row) > w:
                row = row[:w - 1]
            x = 0
            y = idx
            if y < h:
                if idx == selected_row_idx:
                    self.stdscr.attron(curses.color_pair(1))
                    self.stdscr.addstr(y, x, row)
                    self.stdscr.attroff(curses.color_pair(1))
                else:
                    self.stdscr.addstr(y, x, row)
        self.stdscr.refresh()

    def make_query(self, y, x, query, default_value=None, valid_regex=None, validation_func=None, password_mode=False):
        """ÏÇ¨Ïö©Ïûê ÏûÖÎ†•ÏùÑ Î∞õÎäî Ìï®Ïàò"""
        h, w = self.stdscr.getmaxyx()
        input_line = []
        error_msg = ""
        
        while True:
            # ÌôîÎ©¥ ÏßÄÏö∞Í∏∞
            try:
                if y < h and x + len(query) < w:
                    self.stdscr.addstr(y, x, query)
                self.stdscr.clrtoeol()
                
                # ÏûÖÎ†• ÎÇ¥Ïö© ÌëúÏãú (Ìå®Ïä§ÏõåÎìú Î™®ÎìúÎ©¥ * ÌëúÏãú)
                display_text = '*' * len(input_line) if password_mode else ''.join(input_line)
                if y < h and x + len(query) + len(display_text) < w:
                    self.stdscr.addstr(y, x + len(query), display_text, curses.color_pair(COLOR_INFO))
                
                # Ïª§ÏÑú ÌëúÏãú
                if y < h and x + len(query) + len(display_text) < w:
                    self.stdscr.addstr(y, x + len(query) + len(display_text), "‚ñà", curses.color_pair(COLOR_SELECTED))
                
                # Ïò§Î•ò Î©îÏãúÏßÄ ÌëúÏãú
                if error_msg and y + 1 < h:
                    self.stdscr.addstr(y + 1, x, error_msg, curses.color_pair(COLOR_ERROR))
                
            except curses.error:
                pass
            
            key = self.stdscr.getch()
            
            # Î¨∏Ïûê ÏûÖÎ†•
            if 33 <= key <= 126:
                input_line.append(chr(key))
                error_msg = ""
            
            # Î∞±Ïä§ÌéòÏù¥Ïä§
            elif key in (curses.KEY_BACKSPACE, 127, 8):
                if input_line:
                    input_line.pop()
                error_msg = ""
            
            # ÏóîÌÑ∞
            elif key == curses.KEY_ENTER or key in [10, 13]:
                user_input = ''.join(input_line)
                
                # ÏûÖÎ†•Ïù¥ ÏûàÎäî Í≤ΩÏö∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
                if user_input:
                    valid = True
                    
                    # Ï†ïÍ∑úÏãù Í≤ÄÏÇ¨
                    if valid_regex and not re.fullmatch(valid_regex, user_input):
                        valid = False
                        error_msg = "‚ùå ÏûòÎ™ªÎêú ÌòïÏãùÏûÖÎãàÎã§"
                    
                    # Ìï®Ïàò Í≤ÄÏÇ¨
                    elif validation_func and not validation_func(user_input):
                        valid = False
                        error_msg = "‚ùå Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Í∞íÏûÖÎãàÎã§"
                    
                    if valid:
                        return user_input
                
                # ÏûÖÎ†•Ïù¥ ÏóÜÎäî Í≤ΩÏö∞ Í∏∞Î≥∏Í∞í Î∞òÌôò
                elif default_value is not None:
                    return default_value
                else:
                    error_msg = "‚ùå Í∞íÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî"
            
            # ESC
            elif key == 27:
                return ESCAPE_CODE

    def install_astrago(self):
        """Astrago Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏÑ§Ïπò"""
        status = self.data_manager.get_environment_status()
        if not status['configured']:
            self.show_message("‚ùå Î®ºÏ†Ä ÌôòÍ≤Ω ÏÑ§Ï†ïÏùÑ ÏôÑÎ£åÌï¥Ï£ºÏÑ∏Ïöî.", curses.color_pair(3))
            return

        self.stdscr.clear()
        self.stdscr.addstr(0, 0, "üöÄ Astrago Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏÑ§Ïπò", curses.color_pair(1))
        self.stdscr.addstr(1, 0, "=" * 50)
        
        # ÌòÑÏû¨ ÌôòÍ≤Ω Ï†ïÎ≥¥ ÌëúÏãú
        y = 3
        self.stdscr.addstr(y, 0, f"Ïô∏Î∂Ä IP: {status['external_ip']}")
        y += 1
        self.stdscr.addstr(y, 0, f"NFS ÏÑúÎ≤Ñ: {status['nfs_server']}")
        y += 1
        self.stdscr.addstr(y, 0, f"NFS Í≤ΩÎ°ú: {status['nfs_path']}")
        y += 1
        
        if self.installation_mode == 'offline':
            self.stdscr.addstr(y, 0, f"Ïò§ÌîÑÎùºÏù∏ Î†àÏßÄÏä§Ìä∏Î¶¨: {status['offline_registry']}")
            y += 1
            self.stdscr.addstr(y, 0, f"HTTP ÏÑúÎ≤Ñ: {status['offline_http']}")
            y += 1
        
        y += 1
        self.stdscr.addstr(y, 0, "ÏÑ§ÏπòÎ•º ÏãúÏûëÌïòÏãúÍ≤†ÏäµÎãàÍπå? [y/N]: ")
        self.stdscr.refresh()
        
        key = self.stdscr.getch()
        if key not in [ord('y'), ord('Y')]:
            return
        
        process = self.command_runner.run_install_astrago()
        self.read_and_display_output(process)

    def uninstall_astrago(self):
        """Astrago Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ï†úÍ±∞"""
        self.stdscr.clear()
        self.stdscr.addstr(0, 0, "üóëÔ∏è Astrago Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ï†úÍ±∞", curses.color_pair(3))
        self.stdscr.addstr(2, 0, "‚ö†Ô∏è  Î™®Îì† Astrago Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏù¥ Ï†úÍ±∞Îê©ÎãàÎã§!", curses.color_pair(3))
        self.stdscr.addstr(3, 0, "Ï†ïÎßêÎ°ú Ï†úÍ±∞ÌïòÏãúÍ≤†ÏäµÎãàÍπå? [y/N]: ")
        self.stdscr.refresh()
        
        key = self.stdscr.getch()
        if key not in [ord('y'), ord('Y')]:
            return
        
        process = self.command_runner.run_uninstall_astrago()
        self.read_and_display_output(process)

    def manage_individual_apps(self):
        """Í∞úÎ≥Ñ Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Í¥ÄÎ¶¨"""
        apps = [
            "csi-driver-nfs", "gpu-operator", "gpu-process-exporter",
            "loki-stack", "prometheus", "keycloak", "astrago", 
            "harbor", "mpi-operator", "flux"
        ]
        
        selected_app = 0
        action_menu = ["ÏÑ§Ïπò", "Ï†úÍ±∞", "Îí§Î°úÍ∞ÄÍ∏∞"]
        
        while True:
            self.stdscr.clear()
            self.stdscr.addstr(0, 0, "üì¶ Í∞úÎ≥Ñ Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Í¥ÄÎ¶¨", curses.color_pair(1))
            self.stdscr.addstr(1, 0, "ÏÑ§Ïπò/Ï†úÍ±∞Ìï† Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî")
            
            # Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Î™©Î°ù ÌëúÏãú
            for idx, app in enumerate(apps):
                y = 3 + idx
                if y < self.stdscr.getmaxyx()[0] - 2:
                    prefix = "‚ñ∫ " if idx == selected_app else "  "
                    color = curses.color_pair(1) if idx == selected_app else 0
                    self.stdscr.addstr(y, 0, f"{prefix}{app}", color)
            
            self.stdscr.addstr(self.stdscr.getmaxyx()[0] - 2, 0, "‚Üë‚Üì: Ïù¥Îèô | Enter: ÏÑ†ÌÉù | ESC: Îí§Î°úÍ∞ÄÍ∏∞")
            self.stdscr.refresh()
            
            key = self.stdscr.getch()
            
            if key == curses.KEY_UP and selected_app > 0:
                selected_app -= 1
            elif key == curses.KEY_DOWN and selected_app < len(apps) - 1:
                selected_app += 1
            elif key == curses.KEY_ENTER or key in [10, 13]:
                # Ïï°ÏÖò ÏÑ†ÌÉù
                app_name = apps[selected_app]
                action = self.select_action_menu(action_menu, f"{app_name} Í¥ÄÎ¶¨")
                
                if action == 0:  # ÏÑ§Ïπò
                    process = self.command_runner.run_install_astrago(app_name)
                    self.read_and_display_output(process)
                elif action == 1:  # Ï†úÍ±∞
                    self.stdscr.clear()
                    self.stdscr.addstr(0, 0, f"'{app_name}' Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏùÑ Ï†úÍ±∞ÌïòÏãúÍ≤†ÏäµÎãàÍπå? [y/N]: ")
                    self.stdscr.refresh()
                    confirm = self.stdscr.getch()
                    if confirm in [ord('y'), ord('Y')]:
                        process = self.command_runner.run_uninstall_astrago(app_name)
                        self.read_and_display_output(process)
                elif action == 2:  # Îí§Î°úÍ∞ÄÍ∏∞
                    continue
            elif key == 27:  # ESC
                break

    def select_action_menu(self, actions, title):
        """Ïï°ÏÖò Î©îÎâ¥ ÏÑ†ÌÉù"""
        selected = 0
        
        while True:
            self.stdscr.clear()
            self.stdscr.addstr(0, 0, title, curses.color_pair(1))
            
            for idx, action in enumerate(actions):
                y = 2 + idx
                prefix = "‚ñ∫ " if idx == selected else "  "
                color = curses.color_pair(1) if idx == selected else 0
                self.stdscr.addstr(y, 0, f"{prefix}{action}", color)
            
            self.stdscr.refresh()
            key = self.stdscr.getch()
            
            if key == curses.KEY_UP and selected > 0:
                selected -= 1
            elif key == curses.KEY_DOWN and selected < len(actions) - 1:
                selected += 1
            elif key == curses.KEY_ENTER or key in [10, 13]:
                return selected
            elif key == 27:  # ESC
                return len(actions) - 1  # ÎßàÏßÄÎßâ Ìï≠Î™© (Îí§Î°úÍ∞ÄÍ∏∞) Î∞òÌôò

    def install_ansible_query(self, title, install_method, show_table_func=None):
        """SSH Í∏∞Î∞ò ÏÑ§Ïπò ÏøºÎ¶¨"""
        self.stdscr.clear()
        self.stdscr.addstr(0, 0, title, curses.color_pair(1))
        
        if show_table_func:
            show_table_func(3, 0)
            y_start = 8
        else:
            y_start = 2
        
        self.stdscr.addstr(y_start, 0, "Í≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå? [y/N]: ")
        self.stdscr.refresh()
        
        key = self.stdscr.getch()
        if key not in [ord('y'), ord('Y')]:
            return
        
        # SSH Ï†ïÎ≥¥ ÏûÖÎ†•
        username = self.make_query(y_start + 2, 0, "SSH ÏÇ¨Ïö©ÏûêÎ™Ö: ")
        if username == ESCAPE_CODE:
            return
        
        password = self.make_query(y_start + 3, 0, "SSH ÎπÑÎ∞ÄÎ≤àÌò∏: ", password_mode=True)
        if password == ESCAPE_CODE:
            return
        
        process = install_method(username, password)
        self.read_and_display_output(process)

    def install_nfs(self):
        """NFS ÏÑúÎ≤Ñ ÏÑ§Ïπò"""
        if not self.data_manager.nfs_server['ip'] or not self.data_manager.nfs_server['path']:
            self.show_message("‚ùå Î®ºÏ†Ä NFS ÏÑúÎ≤Ñ ÏÑ§Ï†ïÏùÑ ÏôÑÎ£åÌï¥Ï£ºÏÑ∏Ïöî.", curses.color_pair(3))
            return
            
        self.install_ansible_query(
            "üóÇÔ∏è NFS ÏÑúÎ≤Ñ ÏÑ§Ïπò",
            self.command_runner.run_install_nfs,
            self.print_nfs_server_table
        )

    def install_gpu_driver(self):
        """GPU ÎìúÎùºÏù¥Î≤Ñ ÏÑ§Ïπò"""
        if not self.data_manager.nodes:
            self.show_message("‚ùå Î®ºÏ†Ä ÎÖ∏ÎìúÎ•º Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.", curses.color_pair(3))
            return
            
        self.install_ansible_query(
            "üéÆ GPU ÎìúÎùºÏù¥Î≤Ñ ÏÑ§Ïπò (ÏãúÏä§ÌÖúÏù¥ Ïû¨Î∂ÄÌåÖÎê©ÎãàÎã§)",
            self.command_runner.run_install_gpudriver,
            self.print_nodes_table
        )

    def install_kubernetes(self):
        """Kubernetes ÌÅ¥Îü¨Ïä§ÌÑ∞ ÏÑ§Ïπò"""
        if not self.data_manager.nodes:
            self.show_message("‚ùå Î®ºÏ†Ä ÎÖ∏ÎìúÎ•º Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.", curses.color_pair(3))
            return
            
        self.install_ansible_query(
            "‚ò∏Ô∏è Kubernetes ÌÅ¥Îü¨Ïä§ÌÑ∞ ÏÑ§Ïπò",
            self.command_runner.run_kubespray_install,
            self.print_nodes_table
        )
        
        # kubeconfig Î≥µÏÇ¨
        origin_config_path = pathlib.Path("kubespray/inventory/mycluster/artifacts/admin.conf")
        if origin_config_path.exists():
            kubeconfig_path = pathlib.Path.home() / '.kube' / 'config'
            kubeconfig_path.parent.mkdir(parents=True, exist_ok=True)
            kubeconfig_path.write_bytes(origin_config_path.read_bytes())
            self.show_message("‚úÖ KubeconfigÍ∞Ä Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!", curses.color_pair(1))

    def reset_kubernetes(self):
        """Kubernetes ÌÅ¥Îü¨Ïä§ÌÑ∞ Î¶¨ÏÖã"""
        if not self.data_manager.nodes:
            self.show_message("‚ùå Î¶¨ÏÖãÌï† ÌÅ¥Îü¨Ïä§ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.", curses.color_pair(3))
            return
            
        self.install_ansible_query(
            "üîÑ Kubernetes ÌÅ¥Îü¨Ïä§ÌÑ∞ Î¶¨ÏÖã",
            self.command_runner.run_kubespray_reset,
            self.print_nodes_table
        )

    def setting_node_menu(self):
        """ÎÖ∏Îìú ÏÑ§Ï†ï Î©îÎâ¥"""
        menu = ["1. ‚ûï Add Node", "2. ‚ûñ Remove Node", "3. ‚úèÔ∏è Edit Node", "4. üîô Back"]
        self.navigate_sub_menu(menu, {
            0: self.add_node,
            1: self.remove_node,
            2: self.edit_node
        }, self.print_nodes_table)

    def set_nfs_query(self):
        """NFS ÏÑúÎ≤Ñ ÏÑ§Ï†ï"""
        self.stdscr.clear()
        self.stdscr.addstr(0, 0, "üóÑÔ∏è NFS ÏÑúÎ≤Ñ ÏÑ§Ï†ï", curses.color_pair(COLOR_GRADIENT1))
        self.stdscr.addstr(1, 0, "=" * 50)
        
        # ÌòÑÏû¨ ÏÑ§Ï†ï ÌëúÏãú
        y = 3
        current_ip = self.data_manager.nfs_server.get('ip', '')
        current_path = self.data_manager.nfs_server.get('path', '')
        
        self.stdscr.addstr(y, 0, f"ÌòÑÏû¨ NFS IP: {current_ip or 'ÎØ∏ÏÑ§Ï†ï'}")
        y += 1
        self.stdscr.addstr(y, 0, f"ÌòÑÏû¨ NFS Í≤ΩÎ°ú: {current_path or 'ÎØ∏ÏÑ§Ï†ï'}")
        y += 2
        
        # NFS IP ÏûÖÎ†•
        nfs_ip = self.make_query(y, 0, "NFS ÏÑúÎ≤Ñ IP Ï£ºÏÜå: ", 
                               default_value=current_ip,
                               validation_func=self.data_manager.validate_ip)
        if nfs_ip == ESCAPE_CODE:
            return
        
        y += 1
        # NFS Í≤ΩÎ°ú ÏûÖÎ†•
        nfs_path = self.make_query(y, 0, "NFS Í∏∞Î≥∏ Í≤ΩÎ°ú: ", 
                                 default_value=current_path,
                                 validation_func=self.data_manager.validate_path)
        if nfs_path == ESCAPE_CODE:
            return
        
        # ÏÑ§Ï†ï Ï†ÄÏû•
        self.data_manager.set_nfs_server(nfs_ip, nfs_path)
        
        y += 2
        self.stdscr.addstr(y, 0, "‚úÖ NFS ÏÑúÎ≤Ñ ÏÑ§Ï†ïÏù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!", curses.color_pair(COLOR_SUCCESS))
        y += 1
        self.stdscr.addstr(y, 0, "ÏïÑÎ¨¥ ÌÇ§ÎÇò ÎàåÎü¨ Í≥ÑÏÜçÌïòÏÑ∏Ïöî")
        
        self.stdscr.refresh()
        curses.flushinp()
        self.stdscr.getch()

    def setting_nfs_menu(self):
        """NFS ÏÑ§Ï†ï Î©îÎâ¥"""
        menu = ["1. ‚öôÔ∏è Setting NFS Server", "2. üì¶ Install NFS Server(Optional)", "3. üîô Back"]
        self.navigate_sub_menu(menu, {
            0: self.set_nfs_query,
            1: self.install_nfs
        }, self.print_nfs_server_table)

    def print_status_info(self):
        """ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï†ïÎ≥¥ ÌëúÏãú"""
        self.stdscr.clear()
        h, w = self.stdscr.getmaxyx()
        
        # Ï†úÎ™©
        title = "üìä ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï†ïÎ≥¥"
        self.stdscr.addstr(0, 0, title, curses.color_pair(COLOR_GRADIENT1) | curses.A_BOLD)
        self.stdscr.addstr(1, 0, "=" * 60)
        
        y = 3
        status = self.data_manager.get_environment_status()
        
        # ÌôòÍ≤Ω ÏÑ§Ï†ï ÏÉÅÌÉú
        self.stdscr.addstr(y, 0, "üîß ÌôòÍ≤Ω ÏÑ§Ï†ï:", curses.color_pair(COLOR_GRADIENT2))
        y += 1
        
        config_status = "‚úÖ ÏôÑÎ£å" if status['configured'] else "‚ùå ÎØ∏ÏôÑÎ£å"
        config_color = COLOR_SUCCESS if status['configured'] else COLOR_ERROR
        self.stdscr.addstr(y, 2, f"ÏÑ§Ï†ï ÏÉÅÌÉú: {config_status}", curses.color_pair(config_color))
        y += 1
        
        self.stdscr.addstr(y, 2, f"Ïô∏Î∂Ä IP: {status['external_ip'] or 'ÎØ∏ÏÑ§Ï†ï'}")
        y += 1
        self.stdscr.addstr(y, 2, f"NFS ÏÑúÎ≤Ñ: {status['nfs_server'] or 'ÎØ∏ÏÑ§Ï†ï'}")
        y += 1
        self.stdscr.addstr(y, 2, f"NFS Í≤ΩÎ°ú: {status['nfs_path'] or 'ÎØ∏ÏÑ§Ï†ï'}")
        y += 2
        
        # ÎÖ∏Îìú Ï†ïÎ≥¥
        self.stdscr.addstr(y, 0, "üñ•Ô∏è ÎÖ∏Îìú Ï†ïÎ≥¥:", curses.color_pair(COLOR_GRADIENT2))
        y += 1
        self.stdscr.addstr(y, 2, f"Îì±Î°ùÎêú ÎÖ∏Îìú Ïàò: {status['nodes_count']}")
        y += 2
        
        # ÏÑ§Ïπò Î™®Îìú
        self.stdscr.addstr(y, 0, "üîß ÏÑ§Ïπò Î™®Îìú:", curses.color_pair(COLOR_GRADIENT2))
        y += 1
        mode_text = "Ïò§ÌîÑÎùºÏù∏" if self.installation_mode == 'offline' else "Ïò®ÎùºÏù∏"
        self.stdscr.addstr(y, 2, f"ÌòÑÏû¨ Î™®Îìú: {mode_text}")
        y += 1
        
        if self.installation_mode == 'offline':
            self.stdscr.addstr(y, 2, f"Ïò§ÌîÑÎùºÏù∏ Î†àÏßÄÏä§Ìä∏Î¶¨: {status['offline_registry'] or 'ÎØ∏ÏÑ§Ï†ï'}")
            y += 1
            self.stdscr.addstr(y, 2, f"HTTP ÏÑúÎ≤Ñ: {status['offline_http'] or 'ÎØ∏ÏÑ§Ï†ï'}")
            y += 2
        
        # ÎèÑÏõÄÎßê
        help_y = h - 3
        self.stdscr.addstr(help_y, 0, "ÏïÑÎ¨¥ ÌÇ§ÎÇò ÎàåÎü¨ Î©îÎâ¥Î°ú ÎèåÏïÑÍ∞ÄÏÑ∏Ïöî", curses.color_pair(COLOR_INFO))
        
        self.stdscr.refresh()
        curses.flushinp()
        self.stdscr.getch()

    def install_astrago_menu(self):
        """Astrago ÏÑ§Ïπò Î©îÎâ¥"""
        menu = ["1. üóÑÔ∏è Set NFS Server", "2. üöÄ Install Astrago", "3. üóëÔ∏è Uninstall Astrago", "4. üîô Back"]
        self.navigate_menu(menu, {
            0: self.setting_nfs_menu,
            1: self.install_astrago,
            2: self.uninstall_astrago
        })

    def install_kubernetes_menu(self):
        """Kubernetes ÏÑ§Ïπò Î©îÎâ¥"""
        menu = ["1. üñ•Ô∏è Set Nodes", "2. ‚ò∏Ô∏è Install Kubernetes", "3. üîÑ Reset Kubernetes", "4. üéÆ Install GPU Driver (Optional)",
                "5. üîô Back"]
        self.navigate_menu(menu, {
            0: self.setting_node_menu,
            1: self.install_kubernetes,
            2: self.reset_kubernetes,
            3: self.install_gpu_driver
        })

    def navigate_sub_menu(self, menu, handlers, table_handler=None):
        """ÏÑúÎ∏å Î©îÎâ¥ ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò"""
        current_row = 0
        while True:
            self.stdscr.clear()
            
            # Î©îÎâ¥ Ï†úÎ™© ÌëúÏãú
            menu_title = menu[0].split()[0] + " Í¥ÄÎ¶¨"
            self.stdscr.addstr(0, 0, menu_title, curses.color_pair(1))
            
            # Î©îÎâ¥ Ìï≠Î™© ÌëúÏãú
            for idx, item in enumerate(menu):
                y = 2 + idx
                prefix = "‚ñ∫ " if idx == current_row else "  "
                color = curses.color_pair(1) if idx == current_row else 0
                self.stdscr.addstr(y, 0, f"{prefix}{item}", color)
            
            # ÌÖåÏù¥Î∏î ÌëúÏãú
            if table_handler:
                table_y = 2 + len(menu) + 1
                table_handler(table_y, 0)
            
            # ÎèÑÏõÄÎßê
            help_y = self.stdscr.getmaxyx()[0] - 2
            self.stdscr.addstr(help_y, 0, "‚Üë‚Üì: Ïù¥Îèô | Enter: ÏÑ†ÌÉù | ESC: Îí§Î°úÍ∞ÄÍ∏∞")
            
            self.stdscr.refresh()
            
            key = self.stdscr.getch()
            
            if key == curses.KEY_UP and current_row > 0:
                current_row -= 1
            elif key == curses.KEY_DOWN and current_row < len(menu) - 1:
                current_row += 1
            elif key in range(49, 49 + len(menu)):  # Ïà´Ïûê ÌÇ§
                current_row = key - 48 - 1
                if current_row in handlers:
                    handlers[current_row]()
                if current_row == len(menu) - 1:  # Îí§Î°úÍ∞ÄÍ∏∞
                    break
            elif key == curses.KEY_ENTER or key in [10, 13]:
                if current_row in handlers:
                    handlers[current_row]()
                if current_row == len(menu) - 1:  # Îí§Î°úÍ∞ÄÍ∏∞
                    break
            elif key == curses.KEY_BACKSPACE or key == 27:
                break

    def navigate_menu(self, menu, handlers):
        """Î©îÏù∏ Î©îÎâ¥ ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò"""
        current_row = 0
        self.print_menu(menu, current_row)
        
        while True:
            key = self.stdscr.getch()
            
            if key == curses.KEY_UP and current_row > 0:
                current_row -= 1
            elif key == curses.KEY_DOWN and current_row < len(menu) - 1:
                current_row += 1
            elif key in range(49, 49 + len(menu)):  # Ïà´Ïûê ÌÇ§
                current_row = key - 49 - 1
                if current_row in handlers:
                    handlers[current_row]()
                if current_row == len(menu) - 1:  # Ï¢ÖÎ£å/Îí§Î°úÍ∞ÄÍ∏∞
                    break
            elif key == curses.KEY_ENTER or key in [10, 13]:
                if current_row in handlers:
                    handlers[current_row]()
                if current_row == len(menu) - 1:  # Ï¢ÖÎ£å/Îí§Î°úÍ∞ÄÍ∏∞
                    break
            elif key == curses.KEY_BACKSPACE or key == 27:
                break
            
            self.print_menu(menu, current_row)

    def main(self, stdscr):
        """Î©îÏù∏ Ìï®Ïàò"""
        self.stdscr = stdscr
        
        # ==========================================
        # üé® Beautiful Color Initialization
        # ==========================================
        curses.start_color()
        curses.use_default_colors()
        
        # Í∑∏ÎùºÎç∞Ïù¥ÏÖò ÏÉâÏÉÅ Ï†ïÏùò (run_gui_installer.shÏôÄ ÌÜµÏùº)
        curses.init_pair(COLOR_GRADIENT1, 129, -1)  # Purple
        curses.init_pair(COLOR_GRADIENT2, 135, -1)  # Light Purple
        curses.init_pair(COLOR_GRADIENT3, 141, -1)  # Pink
        curses.init_pair(COLOR_GRADIENT4, 147, -1)  # Light Pink
        curses.init_pair(COLOR_SUCCESS, curses.COLOR_GREEN, -1)
        curses.init_pair(COLOR_ERROR, curses.COLOR_RED, -1)
        curses.init_pair(COLOR_WARNING, curses.COLOR_YELLOW, -1)
        curses.init_pair(COLOR_INFO, curses.COLOR_CYAN, -1)
        curses.init_pair(COLOR_SELECTED, curses.COLOR_BLACK, curses.COLOR_GREEN)
        curses.init_pair(COLOR_BORDER, curses.COLOR_BLUE, -1)
        
        # Í∏∞Î≥∏ ÏÑ§Ï†ï
        curses.echo()
        curses.set_escdelay(1)
        curses.curs_set(0)
        
        # Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌïú Í∏∞Î≥∏ ÏÉâÏÉÅ Ïåç
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_GREEN)
        curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
        curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)
        
        main_menu = ["1. üèóÔ∏è Kubernetes Infrastructure",
                     "2. üöÄ Astrago Platform", 
                     "3. ‚öôÔ∏è Environment Settings",
                     "4. üìä System Status",
                     "5. ‚ùå Close"]
        
        try:
            self.navigate_menu(main_menu, {
                0: self.install_kubernetes_menu,
                1: self.install_astrago_menu,
                2: self.configure_environment,
                3: self.print_status_info
            })
        except KeyboardInterrupt:
            pass
        except Exception as e:
            self.stdscr.clear()
            self.stdscr.addstr(0, 0, f"Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {str(e)}", curses.color_pair(COLOR_ERROR))
            self.stdscr.addstr(2, 0, "ÏïÑÎ¨¥ ÌÇ§ÎÇò ÎàåÎü¨ Ï¢ÖÎ£åÌïòÏÑ∏Ïöî")
            self.stdscr.refresh()
            self.stdscr.getch()


if __name__ == "__main__":
    try:
        curses.wrapper(AstragoInstaller().main)
    except KeyboardInterrupt:
        print("\nÌîÑÎ°úÍ∑∏Îû®Ïù¥ ÏÇ¨Ïö©ÏûêÏóê ÏùòÌï¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§.")
    except Exception as e:
        print(f"\nÏò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: {e}")
        sys.exit(1)
